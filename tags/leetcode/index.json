[{"content":"由前一篇文章Part1，我們發現KNN並無法有效地處理影像的問題。主要有兩個問題：\n classifier 必須_儲存_所有 training data，所以需要大量的儲存空間。 分類 test image 時必須與所有training images 做比對。  \r本篇將介紹 Linear Classification，可以說是最基本的Neural Networks處理方法。Linear Classification主要包含兩大內容，score function 與 loss function。\n\nScore Function Score function 主要是將 raw data 轉換為 類別 的分數。比如說我們有一張 32 x 32 的彩色影像，raw data 的資訊就會是 32 x 32 x 3 = 3072 pixels，而假設總共有十種類別(貓、車、飛機等等)。那Score function 就是把3072的維度映射到10維上 $f: R^{3072} \\mapsto R^{10}$，比較簡單的映射方式就是線性映射：\n$$ f(x_i, W, b) = W x_i + b $$\n $x_i$： training image, [3072 x 1] $W$： weights，[10 x 3072] $b$： bias vector, [10 x 1]  我們可以透過調整 $ W $ , $ b $ 讓計算出來的分數能夠匹配ground truth label，直觀的想法就是正確的類別得分會比錯誤類別的得分還高。除此之外，訓練完模型之後，我們只要儲存 $ W $ , $ b $，就可以快速判別test image是否正確。簡單歸納其優點：\n 線性函數，能夠快速訓練模型。 測試集的data不需一一與訓練集進行比較，節省時間。  \r 所謂的 ground truth 指的就是有效的答案或是標準值。\n \r這個線性函數的capacity(意指模型的fitting能力)，主要是依照影像的 R G B色彩來分類，比如說船的影像，由於大部分的情形都在海上或有天空的背景，藍色的比例就會比較多。所以如果要判斷船的影像，藍色的權重 就必須比較大，紅與綠的權重就要比較小。以下是來自CS231_n的範例。\n\r\r這個範例總共分成3個class，red (cat)、 green (dog)、 blue (ship)，而這個weights表現得不好，因為將貓分類成狗了。\n\n不同觀點來理解Score Function 其實根據以上的線性函數，就很好理解了。但是CS231_n課程為我們展示了三種不同觀點來理解Score Function。\n 代數觀點 (Algebraic Viewpoint) 視覺觀點 (Visual Viewpoint) 幾何觀點 (Geometric Viewpoint)  \n代數觀點 (Algebraic Viewpoint) \r每一個影像都是由不同class所組合而成的，權重的每一個row都是一種類別，我們將pixel矩陣對於權重做 inner product，得到的值進行比較，就可以分類出該影像了。\n\r視覺觀點 (Visual Viewpoint) \r影像的分類，其實就是看看這個影像跟某一個類別的影像是不是比較吻合，其實就是上一篇講的 Nearest Neighbor 的概念。看這個影像跟哪一個類別比較靠近。差別在於 Nearest Neighbor 是與每一個training image做比較，而 Linear Classification 中，我們只要跟該類別的一個影像做比對就可以了。\n\r幾何觀點 (Geometric Viewpoint) 32 x 32 x 3 = 3072 pixels，表示輸入的每一張影像都會有3072維度，而如果有10個類別，也就是把3072維度映射至10維，但這樣難以理解。我們假設有一種方法可以讓3072維度的影像映射到2維平面上。\n\r所以$ W $ 、 $ b $可以想像成是每一個類別(對應到row)在二維平面上的直線，weight表示直線的傾斜程度，bias表示直線與原點的距離。如此一來就可以分割出許多範圍，用以區分不同類別的影像。\n\rLinear Classifier 困難點 對於某些case來說，Linear Classifier並無法有效地去分類，像是Non-Linear或是inseparable。\n\r有些問題可以將data先映射到新的平面上，轉換成可分類的問題。\n不過有些難以處理的，可能就要使用別的model來訓練了。\n\n結尾 對於weight與bias，我們該如何去判斷其好壞的程度。再者，如何去調整出適當的weight與bias。這些問題，可以透過Loss Function來取決，並且藉由最小化Loss來得到適當的weight與bias。\n","description":"CNN Learning","id":0,"section":"posts","tags":["cs231n","Image Classification","Linear Classification","python","Deep learning"],"title":"CS231_n Image Classification - part2","uri":"https://stanley98745.github.io/posts/imageclassificationpart2/"},{"content":"Gradient 翻譯為梯度，也就是函數在某個方向上的變化率。 而Image Gradient指的就是影像的顏色或是強度，沿著某個方向的變化程度。 透過Image Gradient我們能夠對影像進行一些處理，像是判別顏色漸變的地方，或是edge detection。\n\n數學型式 Image Gradient 是對著x方向與y方向微分，所以對於一個target pixel，最簡單的Image Gradient就是左右(x方向)與上下(y方向)的微分了。因此影像的梯度就會是一個vector(通常以矩陣型式來表示)：\n$$\\nabla f(x,y) = \\begin{pmatrix} g_x \\\\ g_y \\end{pmatrix} = \\begin{pmatrix} \\frac{\\partial f}{\\partial x} \\\\[8pt] \\frac{\\partial f}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} f(x+1, y) - f(x-1, y) \\\\[8pt] f(x, y+1) - f(x, y-1) \\end{pmatrix}$$\n\r對於梯度來說，最重要的兩個參數就是大小(Magnitude)與方向(Direction)。\n Magnitude: $g = \\sqrt{ g_x^2 + g_y^2 }$ Direction: $\\theta = \\arctan{(g_y / g_x)}$  \r舉個簡單的例子\n\nImage Gradient Vector就會是\n$$\\nabla f = \\begin{pmatrix}f(x+1, y) - f(x-1, y) \\\\[8pt] f(x, y+1) - f(x, y-1)\\end{pmatrix} = \\begin{pmatrix} 90-180 \\\\ 70-40 \\end{pmatrix} = \\begin{pmatrix} -90\\\\ 30 \\end{pmatrix}$$\n Magnitude: $$g = \\sqrt{ (-90)^2 + 30^2 } = 94.868$$ Direction: $$\\theta = \\arctan{(30 / -90)} = -18.435^{\\circ}$$  \n以上的過程都是線性運算。另外對於一張影像來講，通常都是幾十萬到幾百萬個像素，而我們的Operator只有前後或是上下，所以是一個 1x3 或是 3x1 的矩陣。也就是我們不需要global的資訊，只需要local的資訊。對於一個線性運算以及只需要local資訊的做法，我們有一個很實用的運算方式，那就是Convolution。\n不過使用Convolution需要注意一下，以上的Image Gradient Vector的計算方式，用矩陣來看的話會是\n\n不過Convolution的計算方式是會前後相反的，計算方式會是\n\n所以在使用Operator的時候，要注意一下kernel的問題。\n如果不熟悉Convolution的話，可以看一下 Convolution\n\n實作Image Gradient 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026#34;\u0026#34;\u0026#34;\rImage Gradient Vector\r\u0026#34;\u0026#34;\u0026#34;\rimport numpy as np\rfrom scipy import signal as sig\rdata = np.array([[0, 70, 0],\r[180, 255, 90],\r[0, 40, 0]])\rG_x = sig.convolve2d(data, np.array([[0, 0, 0],\r[1, 0, -1],\r[0, 0, 0]]), mode=\u0026#39;same\u0026#39;)\rG_y = sig.convolve2d(data, np.array([[0, -1, 0],\r[0, 0, 0],\r[0, 1, 0]]), mode=\u0026#39;same\u0026#39;)\rprint(f\u0026#39;G_x is \\n{G_x}\u0026#39;)\rprint(f\u0026#39;G_y is \\n{G_y}\u0026#39;)\r  \n常見的Kernels Prewitt：相較於前述的Image Gradient只針對Target pixel上下左右的像素做計算，Prewitt Operator使用了Target pixel的8個周遭像素來做計算。\n$$\\mathbf{G}_x = \\begin{pmatrix}-1 \u0026amp; 0 \u0026amp; +1 \\\\[8pt]-1 \u0026amp; 0 \u0026amp; +1 \\\\[8pt]-1 \u0026amp; 0 \u0026amp; +1\\end{pmatrix} \\ast \\mathbf{A} \\text{ , } \\mathbf{G}_y = \\begin{pmatrix}+1 \u0026amp; +1 \u0026amp; +1 \\\\[8pt]0 \u0026amp; 0 \u0026amp; 0 \\\\[8pt]-1 \u0026amp; -1 \u0026amp; -1\\end{pmatrix} \\ast \\mathbf{A}$$\n\rSobel：對於Target pixel的上下左右像素更為重視，提高了這些像素的權重。\n$$\\mathbf{G}_x = \\begin{pmatrix}-1 \u0026amp; 0 \u0026amp; +1 \\\\[8pt]-2 \u0026amp; 0 \u0026amp; +2 \\\\[8pt]-1 \u0026amp; 0 \u0026amp; +1\\end{pmatrix} \\ast \\mathbf{A} \\text{ , } \\mathbf{G}_y = \\begin{pmatrix}+1 \u0026amp; +2 \u0026amp; +1 \\\\[8pt]0 \u0026amp; 0 \u0026amp; 0 \\\\[8pt]-1 \u0026amp; -2 \u0026amp; -1\\end{pmatrix} \\ast \\mathbf{A}$$\n\nSobel 應用範例 首先我們隨意找一張照片，並把這張照片轉換成灰階，可以透過opencv來完成。並且我們定義Sobel Operator Kernel，最後使用convolve2d來完成。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  import numpy as np\rimport cv2\rimport scipy.signal as sig\rimport matplotlib.pyplot as plt\r# Read image and convert it to grayscale\r img = cv2.imread(\u0026#34;kitties.jpg\u0026#34;, cv2.IMREAD_GRAYSCALE)\r# Define Sobel operator kernels\r kernel_x = np.array([[-1, 0, 1],\r[-2, 0, 2],\r[-1, 0, 1]])\rkernel_y = np.array([[-1, -2, -1],\r[0, 0, 0],\r[1, 2, 1]])\rsobelG_x = sig.convolve2d(img, kernel_x, mode=\u0026#39;same\u0026#39;)\rsobelG_y = sig.convolve2d(img, kernel_y, mode=\u0026#39;same\u0026#39;)\r# Plot the result\r fig = plt.figure()\rax1 = fig.add_subplot(121)\rax2 = fig.add_subplot(122)\rax1.imshow(sobelG_x, cmap=\u0026#39;gray\u0026#39;)\rax2.imshow(sobelG_y, cmap=\u0026#39;gray\u0026#39;)\rax1.set_xlabel(\u0026#34;sobelGx\u0026#34;)\rax2.set_xlabel(\u0026#34;sobelGy\u0026#34;)\rplt.show()\r  \r\n除了自定義Kernel之外，opencv也提供了Sobel Operator給使用者。\n dst = cv.Sobel(src, ddepth, dx, dy[, dst[, ksize[, scale[, delta[, borderType]]]]])\n \r參數說明 粗體字為必選\n src： 輸入影像的陣列。 ddepth： 輸出影像的深度，表示電腦可分辨的色彩數目，越多代表越細膩。參考 dx, dy： 求導階數，0 表示不求導數。 dst：輸出影像的陣列。 ksize：Sobel Kernel的大小，必須為1, 3, 5, 7。 (n x n 的方陣) scale：可以縮放導數的比例，像是 y = a x + b 的 a。 delta：對輸出陣列增減一個bias，像是 y = a x + b 的 b。 borderType：convolution在邊界上的處理方式。  \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  import cv2\r# Read image and convert it to grayscale\r img = cv2.imread(\u0026#34;kitty.jpg\u0026#34;, cv2.IMREAD_GRAYSCALE)\r# Sobel Operator in x, y direction\r Sobel_x = cv2.Sobel(img, cv2.CV_64F, dx=1, dy=0, ksize=3)\rSobel_y = cv2.Sobel(img, cv2.CV_64F, dx=0, dy=1, ksize=3)\rabsX = cv2.convertScaleAbs(Sobel_x)\rabsY = cv2.convertScaleAbs(Sobel_y)\routput = cv2.addWeighted(absX, 0.5, absY, 0.5, 0)\r# Resize images for stitching images\r img = cv2.resize(img, (640, 360))\rabsX = cv2.resize(absX, (640, 360))\rabsY = cv2.resize(absY, (640, 360))\routput = cv2.resize(output, (640, 360))\rresult = cv2.vconcat([cv2.hconcat([img, absX]), cv2.hconcat([absY, output])])\rfont = cv2.FONT_HERSHEY_SIMPLEX\rresult = cv2.putText(result, \u0026#39;original\u0026#39;, (50, 300), font, 1, (255, 255, 255), 1)\rresult = cv2.putText(result, \u0026#39;absX\u0026#39;, (690, 300), font, 1, (255, 255, 255), 1)\rresult = cv2.putText(result, \u0026#39;absY\u0026#39;, (50, 660), font, 1, (255, 255, 255), 1)\rresult = cv2.putText(result, \u0026#39;Both\u0026#39;, (690, 660), font, 1, (255, 255, 255), 1)\rcv2.imshow(\u0026#34;Result\u0026#34;, result)\rcv2.waitKey(0)\rcv2.destroyAllWindows()\r  \r\n以上就是Image Gradient的相關介紹囉! 如果有任何問題的話，都歡迎留言哦!\nref:\n[1] WIKI - Image Gradient\n[2] Object Detection for Dummies\n[3] Convloution\n","description":"Image Processing","id":1,"section":"posts","tags":["Image Processing"],"title":"Image Gradient","uri":"https://stanley98745.github.io/posts/imagegradient/"},{"content":"目錄、路徑 獲取Home目錄 1 2 3 4 5 6 7 8 9  from pathlib import Path\rPath.home()\r# on Windows\r output: WindowsPath(\u0026#39;C:/Users/stanley\u0026#39;)\r# on Linux\r output: PosixPath(\u0026#39;/home/stanley\u0026#39;)\r  \r獲取當前目錄 1 2 3 4 5 6 7 8 9  from pathlib import Path\rPath.cwd()\r# on Windows\r output: WindowsPath(\u0026#39;C:/Users/stanley/mypathlib\u0026#39;)\r# on Linux\r output: PosixPath(\u0026#39;/home/stanley/mypathlib\u0026#39;)\r  \r獲取上層目錄 使用 parent 來獲取上層目錄\n1 2 3 4 5  from pathlib import Path\rPath.cwd().parent\routput: PosixPath(\u0026#39;/home/stanley\u0026#39;)\r  \r如果想要獲取再上一層的目錄\n1 2 3  Path.cwd().parent.parent\routput: PosixPath(\u0026#39;/home\u0026#39;)\r  \r如果想獲得每一層路徑，可以使用 .parents\n1 2 3 4 5 6 7  Path.cwd().parents\routput: \u0026lt;PosixPath.parents\u0026gt;\rlist(Path.cwd().parents)\routput: [PosixPath(\u0026#39;/home/stanley\u0026#39;), PosixPath(\u0026#39;/home\u0026#39;), PosixPath(\u0026#39;/\u0026#39;)]\r  \r每一層資料夾的名稱\n1 2 3  Path.cwd().parts\routput: (\u0026#39;/\u0026#39;, \u0026#39;home\u0026#39;, \u0026#39;stanley\u0026#39;, \u0026#39;mypathlib\u0026#39;)\r  \r當前路徑 假設你在某個資料夾底下，想要找到目標檔案的路徑\n1 2 3 4 5 6  from pathlib import Path\rpath = Path(\u0026#39;test.py\u0026#39;)\rpath.resolve()\routput: PosixPath(\u0026#39;/home/stanley/mypathlib/test.py\u0026#39;)\r  \r拼接路徑 使用 .joinpath() 方法來拼接路徑\n1 2 3 4 5  from pathlib import Path\rPath(\u0026#39;/\u0026#39;).joinpath(\u0026#39;home\u0026#39;, \u0026#39;stanley/mypathlib\u0026#39;)\routput: PosixPath(\u0026#39;/home/stanley/mypathlib\u0026#39;)\r  \r更快的方法是使用 / 運算符\n1 2 3 4 5  from pathlib import Path\rPath(\u0026#39;/\u0026#39;) / \u0026#39;home\u0026#39; / \u0026#39;stanley/mypathlib\u0026#39;\routput: PosixPath(\u0026#39;/home/stanley/mypathlib\u0026#39;)\r  \n檔案、資料夾操作 檔案名稱 有時候我們需要對檔案的檔名、副檔名進行操作\n .name：檔案全名，\u0026lsquo;test.py\u0026rsquo; .stem：檔案名稱，\u0026lsquo;test\u0026rsquo; .suffix：副檔名，'.py\u0026rsquo;  皆會以 string 方式返回\n1 2 3 4 5 6 7 8 9 10  from pathlib import Path\rpath = Path(\u0026#39;test.py\u0026#39;)\rpath.name\rpath.stem\rpath.suffix\routput: \u0026#39;test.py\u0026#39;\routput: \u0026#39;test\u0026#39;\routput: \u0026#39;.py\u0026#39;\r  \r如果檔案有多個副檔名\n1 2 3 4 5  from pathlib import Path\rPath(\u0026#39;test.tar.gz\u0026#39;).suffixes\routput: [\u0026#39;.tar\u0026#39;, \u0026#39;.gz\u0026#39;]\r  \r想要更改檔名或是副檔名，可以透過 .replace\n1 2 3 4 5  from pathlib import Path\rpath = Path(\u0026#39;test.py\u0026#39;)\rpath.replace(\u0026#39;test.txt\u0026#39;)\r  不過要小心，path 還是原本的 'test.py'\n\r讀/寫檔案 假設現在 mypathlib 資料夾底下有 test.py 檔案\n讀寫檔案的方式可以利用 with open\n1 2 3 4 5 6 7 8  from pathlib import Path\rpath = Path.cwd() / \u0026#39;test.py\u0026#39;\rwith open(path, \u0026#39;r\u0026#39;) as f:\rtest = [line.strip() for line in f]\rprint(\u0026#39;\\n\u0026#39;.join(test))\r  \r輸出就會是\n1 2 3 4 5 6 7  # test\r print(\u0026#39;Test!!\u0026#39;)\r# end\r print(\u0026#39;End\u0026#39;)\r  \r也可以使用 .open() 方法來開啟\n1 2  with path.open(\u0026#39;r\u0026#39;) as f:\r...\r  除此之外，有一些比較簡易的讀寫方法\n .read_text(): 以 text 模式開啟，內容以 string 顯示 .read_bytes(): 以 binary 模式開啟，內容以 bytestring 顯示 .write_text(): 以 string 方式寫入檔案 .write_bytes(): 以 binary 模式開啟並寫入檔案  \rmkdir 與 rmdir 我們可以透過 pathlib 來建立資料夾\n1 2 3  from pathlib import Path\rPath(\u0026#39;00\u0026#39;).mkdir()\r  \r如果要刪除資料夾\n1 2 3  from pathlib import Path\rPath(\u0026#39;00\u0026#39;).rmdir()\r  \r如果要建立多層目錄的話，就需要透過 parents=True\n直接建立的話則會報錯\n1 2 3  from pathlib import Path\rPath(\u0026#39;00/11\u0026#39;).mkdir(parents=True)\r  \r對於刪除多層目錄，就比較麻煩了\n如果在沒有淨空資料夾的情況，直接刪除的話\n1 2 3  from pathlib import Path\rPath(\u0026#39;00/11\u0026#39;).rmdir()\r  \r則會報錯\nOSError: [Errno 39] Directory not empty: '00'\n\r稍微google了一下，比較好的解決方式\n1 2 3 4 5 6 7 8 9 10 11 12  from pathlib import Path\rdef rm_tree(pth):\rpth = Path(pth)\rfor child in pth.glob(\u0026#39;*\u0026#39;):\rif child.is_file():\rchild.unlink()\relse:\rrm_tree(child)\rpth.rmdir()\rrm_tree(\u0026#39;00\u0026#39;)\r  \r只要把刪除路徑的第一層資料夾放進去就可以了。\n\nos、pathlib 比較 最後就列出 os 與 pathlib 比較囉!\n   os and os.path pathlib     os.path.abspath() Path.resolve()   os.chmod() Path.chmod()   os.mkdir() Path.mkdir()   os.rename() Path.rename()   os.replace() Path.replace()   os.rmdir() Path.rmdir()   os.remove(), os.unlink() Path.unlink()   os.getcwd() Path.cwd()   os.path.exists() Path.exists()   os.path.expanduser() Path.expanduser() and Path.home()   os.path.isdir() Path.is_dir()   os.path.isfile() Path.is_file()   os.path.islink() Path.is_symlink()   os.stat() Path.stat(), Path.owner(), Path.group()   os.path.isabs() PurePath.is_absolute()   os.path.join() PurePath.joinpath()   os.path.basename() PurePath.name   os.path.dirname() PurePath.parent   os.path.samefile() Path.samefile()   os.path.splitext() PurePath.suffix    ref:\n[1] python-pathlib\n[2] Python 3\u0026rsquo;s pathlib Module: Taming the File System\n[3] PathLib recursively remove directory?\n","description":"Introduce to Pathlib","id":2,"section":"posts","tags":["python","Pathlib"],"title":"Python skill -- Pathlib","uri":"https://stanley98745.github.io/posts/pathlib/"},{"content":"前言 當我們訓練完模型，並且想要針對結果來鑑別模型的好壞，這時候我們可以透過一些指標來判定。而在深度學習中，最有名的就是 Precision 跟 Recall ，中文翻譯分別為精確率與召回率。\n我們來講一下準確率(Accuracy)會遇到的盲點。假設你早就知道垃圾郵件佔的比例大概為 4% ，那你只要判斷垃圾郵件的模型設置為，把全部郵件判斷為正常郵件 ，準確率就會高達 96% 。但對於實務上來說，這個模型一點用處都沒有。\n所以說準確率會遇到一些限制，這時候我們就要考慮 Precision 跟 Recall 。有一個常用的指標稱做是 Confusion Matrix，中文翻譯為混淆矩陣。\n\n混淆矩陣 \r    實際 (O) 實際 (X)     預測 (O) True Positive False Positive   預測 (X) False Negative True Negative    \r  True：預測與實際上相符 。\n  False：預測與實際上不相符 。\n  Positive：預測正確的情況。\n  Negative：預測不正確的情況\n  \r簡單來區分就是\nTrue/False 表示預測正確與否。\nPositive/Negative 不論預測結果是否正確，只是表示預測的情況，這邊我們用正向與反向來表示。\n\nPrecision \u0026amp; Recall Precision就是求在預測(O)的情況下，實際也是(O)的比例，而Recall就是在實際(O)的情況下，預測為(O)的比例。\n$$Precision = \\frac {TP} {TP + FP}$$\n$$Recall = \\frac {TP} {TP + FN}$$\n\r舉個例子來說，假設你家門口安裝了智慧門鎖，需要用指紋才能進入。此時使用你的指紋進家門，就會是 True Positive。而你的好朋友小偉按壓他的指紋想要進你家，發現進不去，這個情況就會是 True Negative。\n可是人算不如天算，你發現另一個好朋友小志，居然用他的指紋通過了你家的智慧門鎖，這類情況我們稱作是 False Positive，預測是YES但實際上是NO，又稱做是 Type I Error。\n再來的一段時日，你交了個女朋友\u0026ndash;小芳，你把小芳的指紋輸入了系統，這樣她來你家的時候就可以直接進來。結果她第一次使用智慧門鎖就被卡在外面，因為系統判定她不是能夠進入的人。這類情況稱作是 False Negative，預測是NO但實際上是YES，又稱做是 Type II Error。\n\r基本上我們希望模型能夠預測得越準越好，但事實就是不盡人意。所以我們需要根據應用場景，來取決哪一種Error是需要避免的。比如說廣告投放，我們希望寧可錯殺也不可以放過，此時就可以容許Type I Error比較高，Type II Error則需要比較低。而對於以上的門鎖狀況，則會是希望Type II Error比較高，Type I Error則比較低。\n\r所以Precision跟Recall差別只在分母，那麼實際上的意義代表什麼呢? Precision就是在預測正向的情況下，實際上的準確度是多少。而Recall表示的是在實際為正向的情況下，能夠存在、召回多少預測與實際相符的答案。\n比如說以上的廣告投放，我們希望的是Type II Error比較低，也就是False Negative的數據要比較少，所以就是Recall要高。而Type I Error 高不高都沒有關係，也就是Precision對這個case來說不重要。\n而在門鎖系統中Type I Error則希望比較低，也就是False Positive要低，所以Precision就很重要。而Type II Error 不太重要，也就是我們不太在意Recall。\n\r True Negative 為何不考慮?\n \r因為在正常的命題之下，實際與預測正向的結果通常比負向的還少。可以想成你有100萬張圖片，要來判定是不是貓咪，那你一定會蒐集一大堆不是貓咪的照片，所以實際不是貓而且預測也不是貓的結果，就會非常非常多。因此True Negative的量絕對是最多的，而且用處也不大。\n\nF Measure 如果我們現在覺得Precision跟Recall都很重要，該怎麼樣去統合這個標準呢?\n\r 採用 F Measure\n \r而 F Measure 的公式為\n$$F_\\beta = (1+\\beta ^2) \\times \\frac {Precision \\times Recall} {(\\beta ^2 \\times Precision) + Recall}$$\n\r當 $\\beta = 0$，就是 Precision\n當 $\\beta = \\infty$，就是 Recall\n如果今天希望Precision比重比較高，則 beta 要小一點。 希望Recall比重比較高，則 beta 要大一點。\n\r當 $\\beta = 1$，就叫作 F1 Score，表示Precision跟Recall重要程度相當。\n\r而F1 Score所使用的平均方法為調和平均，大家可能會對這個平均方法有點疑惑，一般常用的不就是算術平均嗎? 為何現在要使用調和平均?\n\n調和平均 調和平均(Harmonic mean)，最經典的用法就是計算平均速率。調和平均數是將所有數值取了倒數之後，計算其算術平均數，再將得到的數字取倒數。\n\r相關應用有什麼呢?\n還記得國高中學過的電阻並聯、縮減質量吧?\n當兩個電阻 R1 R2 並聯時，等效電阻就會是\n$$\\frac{1} {\\frac{1} {R_1} + \\frac{1} {R_2}}$$\n\r而縮減質量(Reduced Mass) 就是雙星運動的有效慣性質量，方程式為\n$$\\frac{1} {\\frac{1} {m_1} + \\frac{1} {m_2}}$$\n\r以上的並聯等效電阻以及縮減質量，恰好都是調和平均數的 $\\frac {1} {n}$。\n平均速率、並聯等效電阻和縮減質量等相關應用，數據都是呈現倒數關係，因此使用調和平均來作相關計算。\n而由於上述提到的Precision跟Recall，其分子是相同的，唯一的差別在於分母，也就是呈現所謂的倒數關係。所以這裡我們在F-Measure使用調和平均數。\n\n結尾 除了Precision跟Recall之外，在醫學方面也利用混淆矩陣建立的不少指標，像是Prevalence、Specificity等等，但這些與機器學習的關係比較遠，如果對於這些指標有興趣的人，也可以透過WIKI來了解更多。那有關Precision跟Recall的介紹就到這邊囉!\n\nref[1]：如何辨別機器學習模型的好壞？秒懂Confusion Matrix\nref[2]：WIKI \u0026ndash; Confusion Matrix\nref[3]：Precision, Recall, F1-score簡單介紹\nref[4]：心理學和機器學習中的 Accuracy、Precision、Recall Rate 和 Confusion Matrix\nref[5]：WIKI \u0026ndash; Harmonic mean\n","description":"Deep Learning","id":3,"section":"posts","tags":["Deep learning"],"title":"Precision and Recall","uri":"https://stanley98745.github.io/posts/precisionrecall/"},{"content":"題目敘述 題目連結\n\r難度: Easy\n\rGiven an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.\nEach letter in the magazine string can only be used once in your ransom note.\nExample 1:\nInput: ransomNote = \u0026quot;a\u0026quot;, magazine = \u0026quot;b\u0026quot;\rOutput: false\rExample 2:\nInput: ransomNote = \u0026quot;aa\u0026quot;, magazine = \u0026quot;ab\u0026quot;\rOutput: false\rExample 3:\nInput: ransomNote = \u0026quot;aa\u0026quot;, magazine = \u0026quot;aab\u0026quot;\rOutput: true\rConstraints:\n You may assume that both strings contain only lowercase letters.  \n解答 1 2 3 4 5 6 7 8 9 10 11 12  class Solution:\rdef canConstruct(self, ransomNote: str, magazine: str) -\u0026gt; bool:\rfor w in ransomNote:\rtemp = magazine.replace(w, \u0026#39;\u0026#39;, 1) if len(temp) == len(magazine):\rreturn False magazine = temp\rreturn True\r  結果 \rRuntime: 24 ms, faster than 99.79% of Python3 online submissions for Ransom Note.\nMemory Usage: 13.9 MB, less than 25.00% of Python3 online submissions for Ransom Note.\n\r思路 \r極其簡單的一題，基本上掌握題目就可以寫出來了。\n主要是 magazine 上的字，你只能重複使用一次。\n所以假設 ransomNote 為 aab，而 magazine 為 abc\n那就代表false，因為 magazine 只有一個 a\n\r首先我們先遍歷 ransomNote 中的字元，使用空字串直接 replace 掉 magazine 的相同字元。\n如果被replace了，表示長度一定不相等。反之，長度相等代表根本沒有這個字元。\n判斷完之後，將 temp 寫入原本的 magazine，繼續遍歷。\n\r非常簡單，應該是新手練習python的好題目。\n","description":"LeetCode Solving","id":4,"section":"posts","tags":["leetcode","python"],"title":"LeetCode - 383. Ransom Note","uri":"https://stanley98745.github.io/posts/383.ransomnote/"},{"content":"題目敘述 題目連結\n\r難度: Easy\n\rGiven an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nExample :\nInput: [0,1,0,3,12]\rOutput: [1,3,12,0,0]\rNote:\n You must do this in-place without making a copy of the array. Minimize the total number of operations.  \n解答 1 2 3 4 5 6 7 8 9 10 11 12  class Solution:\rdef moveZeroes(self, nums: List[int]) -\u0026gt; None:\r\u0026#34;\u0026#34;\u0026#34;\rDo not return anything, modify nums in-place instead.\r\u0026#34;\u0026#34;\u0026#34;\rp = 0\rfor i in range(len(nums)):\rif nums[i] != 0:\rnums[i], nums[p] = nums[p], nums[i]\rp += 1\r  結果 \rRuntime: 52 ms, faster than 54.25% of Python3 online submissions for Move Zeroes.\nMemory Usage: 14.9 MB, less than 5.97% of Python3 online submissions for Move Zeroes.\n\r思路 \r其實這題的概念很像是 Bubble Sort，差別是在本題是要移動0到最後面。\n題目要求不能複製陣列，並且盡可能的減少操作次數，也就是交換次數越少越好。\n\r所以我們需要兩個 pointer，一個用來遍歷整個陣列，另一個則用來記錄遇到 0 的位置。\n首先讓 i 一直往前去判斷是否遇到 0，如果遇到了 0，則讓index往下一個位置移動。如果遇到非 0 的元素，則 i 跟 pointer 繼續往前進，並且交換 i 跟 pointer 當下位置的元素。\n\r舉 [3, 4, 0, 1] 為例子\ni = 0, p = 0： [3, 4, 0, 1] nums[i] = 3, nums[p] = 3, 交換\ni = 1, p = 1： [3, 4, 0, 1] nums[i] = 4, nums[p] = 4, 交換\ni = 2, p = 2： [3, 4, 0, 1] nums[i] = 0, nums[p] = 0, 不交換, p 不加 1\ni = 3, p = 2： [3, 4, 0, 1] nums[i] = 1, nums[p] = 0, 交換\n最後一次交換就會變成 [3, 4, 1, 0]\n\r再舉個例子 [3, 0, 0, 1, 2]\ni = 0, p = 0： [3, 0, 0, 1, 2] nums[i] = 3, nums[p] = 3, 交換\ni = 1, p = 1： [3, 0, 0, 1, 2] nums[i] = 0, nums[p] = 0, 不交換, p 不加 1\ni = 2, p = 1： [3, 0, 0, 1, 2] nums[i] = 0, nums[p] = 0, 不交換, p 不加 1\ni = 3, p = 1： [3, 0, 0, 1, 2] nums[i] = 1, nums[p] = 0, 交換\ni = 4, p = 2： [3, 1, 0, 0, 2] nums[i] = 2, nums[p] = 0, 交換\n最後一次交換就會變成 [3, 1, 2, 0, 0]\n\r以上就是Move Zeroes的解法囉!\n","description":"LeetCode Solving","id":5,"section":"posts","tags":["leetcode","python"],"title":"LeetCode - 283. Move Zeroes","uri":"https://stanley98745.github.io/posts/283.movezeroes/"},{"content":"前言 影像分類(Image Classification)主要的作法是將輸入的影像做辨識並且分門別類。這對於電腦視覺的領域來說，是重要且核心的議題之一。比如說我們想在一張圖片上分辨人、貓、車子，或是在一堆車子的影像中分辨出不同品牌或是不同種類的車子。\n那怎麼去做影像分類呢? 首先我們要先了解影像的結構。\n我們知道光的三原色是 R G B ，在電腦硬體上採取每一個像素以24位元的表示方式，每個位元以二進位方式儲存，那光的三原色就各佔了1/3，就是8bits。所以每一種原色的強度就會依照8bits的最高值28分成256個值，表示範圍從0~255。\n假設一張 800 x 600 的彩色圖片，裡面所包含的資訊就會有\n 800 x 600 x 3 = 1440000\n 假設解析度更好，比如說是4K解析度，那資訊量基本上是非常龐大的。\n\n\nChallenges 根據拍攝的場景與情形，其實會造成很多在實際上應用的難處。我們這邊複製cs231n的筆記內容來簡單講述一下會遇到的問題。\n\n\n  Viewpoint variation. A single instance of an object can be oriented in many ways with respect to the camera.\n  Scale variation. Visual classes often exhibit variation in their size (size in the real world, not only in terms of their extent in the image).\n  Deformation. Many objects of interest are not rigid bodies and can be deformed in extreme ways.\n  Occlusion. The objects of interest can be occluded. Sometimes only a small portion of an object (as little as few pixels) could be visible.\n  Illumination conditions. The effects of illumination are drastic on the pixel level.\n  Background clutter. The objects of interest may blend into their environment, making them hard to identify.\n  Intra-class variation. The classes of interest can often be relatively broad, such as chair. There are many different types of these objects, each with their own appearance.\n\n  Viewpoint variation 針對同一個物體來說，假設我們今天從不同角度拍攝他，可能因為周遭的光線或是有遮蔽物等等的因素，會造成pixel的變化。pixel一但有變化，有可能會造成辨別的困難增加。\n\n\nScale variation 辨識的物件相對於其他物件的對比大小，包含在影像裡與現實生活中。\n\nIllumination conditions 剛剛有提到電腦硬體中的三原色儲存方式，0~255表示該原色的亮度。你應該看過有些照片在逆光下，人的臉孔根本完全看不清楚。所以環境的明暗程度，將會影響到辨識的正確率。\n\n\nDeformation 有看到我們可愛的貓貓嗎? 俗話說貓貓就跟液體一樣會變形，變形之後怎麼有辦法讓電腦辨識得出來呢? 現實生活中生物都是非剛體的，所以變形的情況也是需要去克服的。\n\n\r 這裡的 Deformation 指的是體態的不同，並不是像前面viewpoint中，在不同角度看同一個物件的形狀不同。\n \nOcclusion 中文翻譯叫做咬合，實際上的意思就是說，有興趣的物件被部分遮蔽了。我們可能看到貓尾巴，就知道那邊有一隻貓，但是電腦卻分類不出來。\n\n 物件被部分遮蔽了，顯露出來的地方只有幾個像素的大小。\n \nBackground clutter 白貓在雪地，黑貓站在黑布上，橘貓在枯黃的草地上享受夕陽，如果連我們都不仔細看，就會遺漏啊!更何況是電腦了，根本辨識不出來。\n\n\n 簡單來講就是，環境保護色。\n \nIntraclass variation 相同名稱但是卻不同形狀、顏色，像是圖片上的貓咪顏色不同，或是椅子有不同的形狀。該怎麼去分門別類，就要針對實際應用囉!\n\n\n資料驅動的處理方式 (Data-driven Approach) 一般我們在寫排序相關的演算法，都是在程式裡面指定說我們想用什麼方式來做。但對於處理影像辨識的問題，因為辨識的情況依照各自領域的不同，演算法並不是那麼統一，因此大多採用資料驅動的處理方式 (Data-driven Approach) 。\n提供大量不同類別的examples，並發展一個「學習演算法」來瀏覽這些examples，並學習這些類別的 「視覺外觀」 。學習的資料集我們稱做 traning set，測試完之後要驗證正確性的資料集稱做 testing set。其實這種學習的方法，我們就稱做是 機器學習 。\n那麼整個機器學習的流程是什麼呢?\n  收集影像 (images) 與標籤 (label) 的資料集 利用機器學習的方法來訓練分類器 (classifier) 在新的影像上評估這個分類器是否有效   以上的label就是類別一樣，比如說標記成狗、貓、飛機之類的。\n以CIFAR10為例\n\n\n這邊附上 CS231_n 的 image classification pipeline原文\n  Input: Our input consists of a set of N images, each labeled with one of K different classes. We refer to this data as the training set.\n  Learning: Our task is to use the training set to learn what every one of the classes looks like. We refer to this step as training a classifier, or learning a model.\n  Evaluation: In the end, we evaluate the quality of the classifier by asking it to predict labels for a new set of images that it has never seen before. We will then compare the true labels of these images to the ones predicted by the classifier. Intuitively, we’re hoping that a lot of the predictions match up with the true answers (which we call the ground truth).\n  \nClassification Nearest Neighbor Classifier 影像辨識常會用到 Convolutional Neural Networks (CNN) ，但是這個Nearest Neighbor Classifier卻跟CNN毫無相關，充其量只是讓我們了解機器學習的一種處理方式而已。\nCS231_n 筆記裡面提到 nearest neighbor classifier的處理方式:\n The nearest neighbor classifier will take a test image, compare it to every single one of the training images, and predict the label of the closest training image.\n 有兩個重點\n 找test image跟\u0026quot;每一個\u0026rdquo; train image做比較。 判斷此test image跟label的關係遠近。  第一點很好理解，就是把某張測試集的圖片，對訓練集的每一張圖片進行比對，然後用分數，也就是一個函數來評估是否屬於這個類別。\n第二點，也就是關於這個函數，該用什麼函數來表示之間關係的遠近程度? 絕對值就可以嗎? 兩點距離公式嗎? 這個問題就是 Metric 或稱作是 distance function ，詳細過程不在這邊敘述，可以參考以下資料。\nMetric\nmetric-learn: Metric Learning in Python\n\n這邊的distance function是採用下列的方式計算的。每一格的值相減完之後，取完絕對值在將每一格相加起來。\n\n\n簡單的Nearest Neighbor Classifier實作大概如下。如果要詳細看介紹的話\nnearest-neighbor-classifier\n這邊就不再說明 nearest-neighbor-classifier 該如何實作了，因為準確性也不高。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  import numpy as np\rclass NearestNeighbor(object):\rdef __init__(self):\rpass\rdef train(self, X, y):\r\u0026#34;\u0026#34;\u0026#34; X is N x D where each row is an example. Y is 1-dimension of size N \u0026#34;\u0026#34;\u0026#34;\r# the nearest neighbor classifier simply remembers all the training data\r self.Xtr = X\rself.ytr = y\rdef predict(self, X):\r\u0026#34;\u0026#34;\u0026#34; X is N x D where each row is an example we wish to predict label for \u0026#34;\u0026#34;\u0026#34;\rnum_test = X.shape[0]\r# lets make sure that the output type matches the input type\r Ypred = np.zeros(num_test, dtype = self.ytr.dtype)\r# loop over all test rows\r for i in range(num_test):\r# find the nearest training image to the i\u0026#39;th test image\r # using the L1 distance (sum of absolute value differences)\r distances = np.sum(np.abs(self.Xtr - X[i,:]), axis = 1)\rmin_index = np.argmin(distances) # get the index with smallest distance\r Ypred[i] = self.ytr[min_index] # predict the label of the nearest example\r return Ypred\r  \nk - Nearest Neighbor Classifier (KNN) [看我如何實作knn (ongoing)]\n 找出k個與目標比較相近的圖片，並讓這k個圖片「投票」選出目標的類別。\n 所以上述條件在 k = 1 時，就是前一個章節提到的 Nearest Neighbor Classifier 。\n\n\n所以我們現在的問題是，k 到底該怎麼選擇?\n\n超參數調整 (Hyperparameter tuning) k 如何選擇? 該選擇什麼樣的distance function? 這些選擇我們叫作超參數 (hyperparameter) ，也就是如何設置演算法的參數。那該如何選擇這些參數呢?\n 一個一個調整。\n 沒錯就是一個一個調整。\nk = 1, performance = \u0026hellip;\nk = 2, performance = \u0026hellip;\nk = 3, performance = \u0026hellip;\n並且參數的調整還是 problem-dependent ，取決於你想要用在地方，參數調整也會不同。\n根據我們上面的討論，我們資料集會分成 training set 與 testing set ，所以我們調整超參數的方式就是 (假設我們只考慮k的調整好了)\n 選擇一個k值，去train。 驗證看看testing set的準確率如何，如果不滿意，在更動k值 回去重新train  至此，恭喜你，當你把train好的模型放到實際應用端時，你會發現你有 大麻~煩 囉!\n\n為什麼?\n\n因為部署到應用端時，你所接收到的是新的資料集，這些新的資料集不一定能夠完好的符合你的model，也就是不知道這個演算法是不是適合新的data，比較好的作法是\n 將資料集切成traing, validation, testing 選擇一個k值，去train。 驗證validation set的準確率，如果不滿意，更動k值回去重新train 結果滿意之後，在testing set進行測試。  \n\nCross-validation 當training data太少，那我們就會使用Cross-validation來作hyperparameter tuning。\n比如說我們把training set 切成 n 等分，把其中一個fold當作是validation set，然後進行training。接著把validation set改為下一個fold，再進行training。如此反覆總共作n次，最後將這些performance進行成效比較\n\n\n如果對其他的Cross-validation也有興趣，可以看以下的介紹\n交叉驗證(Cross-validation, CV)\n總結 KNN的優點在於training的時間很短，因為只有將data作切割與儲存。但是在test time卻很漫長，因為必須去比較 每一個 training image。但是我們所希望的是在testing時可以馬上就得到yes or no的結果。所以KNN其實不適合用在影像辨識上。\n如果你想觀看原文的note可以點選\ncs231_n image classification notes\n想看如何實作KNN [看我如何實作knn (ongoing!!)]\n那麼下一篇就是 [Linear Classification]\n","description":"CNN Learning","id":6,"section":"posts","tags":["cs231n","Image Classification","KNN","python","Deep learning"],"title":"CS231_n Image Classification - part1","uri":"https://stanley98745.github.io/posts/imageclassification/"},{"content":"題目連結\n\r難度: Medium\n\r題目敘述 Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0?\nFind all unique triplets in the array which gives the sum of zero.\nNote:\nThe solution set must not contain duplicate triplets.\nExample:\nGiven array nums = [-1, 0, 1, 2, -1, -4],\rA solution set is:\r[\r[-1, 0, 1],\r[-1, -1, 2]\r]\r\n解答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class Solution:\rdef threeSum(self, nums: List[int]) -\u0026gt; List[List[int]]:\rfirst = 0\rsecond, third = first + 1, len(nums) - 1\rnums.sort()\rans = set()\rfor first in range(len(nums)-2):\rif first != 0 and nums[first-1] == nums[first]:\rcontinue\rsecond, third = first + 1, len(nums) - 1\rwhile second \u0026lt; third:\rtarget = nums[first] + nums[second] + nums[third]\rif target == 0:\rans.add((nums[first], nums[second], nums[third]))\rsecond += 1\rthird -= 1\relif target \u0026lt; 0:\rsecond += 1\relse:\rthird -= 1\rreturn map(list, ans)\r  \r結果 \rRuntime: 952 ms, faster than 57.34% of Python3 online submissions for Longest Substring Without Repeating Characters.\nMemory Usage: 16.8 MB, less than 53.57% of Python3 online submissions for Longest Substring Without Repeating Characters.\n\r思路 \r 先讓 nums 經過由小到大的排序。  \n 我們讓 first 等於第一個數字，second為first後一個數字，third則從最後面數來。\n舉sorting過的例子來說\n nums = [-5, -2, -1, 3, 4, 6, 8]\nfirst = nums[0] = -5\nsecond = nums[1] = -2\nthird = nums[7] = 8\nfirst + second + third = (-5) + (-2) + (8) = 1\n 以上結果發現總和比 0 還大，表示third的數字太大\n我們讓third往前移一格到nums[6]\n  \r nums = [-5, -2, -1, 3, 4, 6, 8]\nfirst = nums[0] = -5\nsecond = nums[1] = -2\nthird = nums[6] = 6\nfirst + second + third = (-5) + (-2) + (6) = -1\n 此時發現總和比0還小，表示second的數字太小\n於是移動second到下一格，也就是nums[2]\n\r nums = [-5, -2, -1, 3, 4, 6, 8]\nfirst = nums[0] = -5\nsecond = nums[2] = -1\nthird = nums[6] = 6\nfirst + second + third = (-5) + (-1) + (6) = 0\n 發現這個組合滿足等於0的條件，於是加入到ans裡面\n\n 會不會遇到重複的例子? 有可能\n那該怎麼避免呢?\n我們把 ans 改為 set，這樣當我們加入總和為0的組合時，就可以幫我們過濾掉了。\n最後return時，再使用map函數，將其轉成list。\n  \n 有沒有辦法再加快速度?\n舉個例子，像是 [-1, -1, 0, 1, 2, 3]\nfirst 在 nums[0] 跟 nums [1] 時\n其實nums[1]的組合情形都包含在nums[0]的情況下了\n所以我們可以省略 nums[1] 的情形，\n也就是 if first != 0 and nums[first-1] == nums[first]: 的時候\n就讓for迴圈 continue\n  \n以上就是 3sum 的解法囉!\n","description":"LeetCode Solving","id":7,"section":"posts","tags":["leetcode","python"],"title":"LeetCode - 15. 3Sum","uri":"https://stanley98745.github.io/posts/15.3sum/"},{"content":"題目連結\n\r難度: Medium\n\r題目敘述 Given a string, find the length of the longest substring without repeating characters.\nExample 1:\nInput: \u0026quot;abcabcbb\u0026quot;\rOutput: 3\rExplanation: The answer is \u0026quot;abc\u0026quot;, with the length of 3.\r\rExample 2:\nInput: \u0026quot;bbbbb\u0026quot;\rOutput: 1\rExplanation: The answer is \u0026quot;b\u0026quot;, with the length of 1.\r\rExample 3:\nInput: \u0026quot;pwwkew\u0026quot;\rOutput: 3\rExplanation: The answer is \u0026quot;wke\u0026quot;, with the length of 3.\rNote that the answer must be a substring, \u0026quot;pwke\u0026quot; is a subsequence and not a substring.\r\n解答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution:\rdef lengthOfLongestSubstring(self, s: str) -\u0026gt; int:\rans = 0\rstart = 0\rused = {}\rfor index, char in enumerate(s):\rif used.__contains__(char) and start \u0026lt;= used[char]:\rstart = used[char] + 1\relse:\rans = max(ans, index - start + 1)\rused[char] = index\rreturn ans\r  \r結果 \rRuntime: 48 ms, faster than 94.18% of Python3 online submissions for Longest Substring Without Repeating Characters.\nMemory Usage: 13.9 MB, less than 5.10% of Python3 online submissions for Longest Substring Without Repeating Characters.\n\r思路 \r我們會使用dictionary來紀錄，把字元當 key 而 index 當 value。\n1  used[char] = index\r  \r如果 沒有 遇到重複的字元，\n我們就比較當前的不重複的長度 ans\n與\nstart到index的長度\n看看哪個比較長\n1  ans = max(ans, index - start + 1)\r  \r再來，我們要判斷是否遇到相同字元，可以透過 contains 來判斷\nif used.__contains__(char)\n接著start移動到這個字元的下一個index\n舉例來說是 a bcabcaa\n遇到重複的a\nstart就會移動到\na b cabcaa\n再舉個例子\ns = \u0026quot;tmmzuxt\u0026quot;\nstart 一開始在 index 為 0的位置\n而當index移動到第二個m，觸發 if 的條件之後\n我們希望start移動到第二個m\n所以可以用 start = used[char] + 1\n因為當下紀錄的 used[\u0026quot;m\u0026quot;] = 1\n\n但上述會有一個問題，當遇到後面的 t\n程式判斷遇到重複的t，就移動start到 used[\u0026ldquo;t\u0026rdquo;] = 0 並且 start = 0 + 1 = 1\n並沒有任何作用\n所以我們把 if 的條件修改為\nif used.__contains__(char) and start \u0026lt;= used[char]:\n判斷 start 是否 \u0026lt;= used[char]\n如果沒有的話，代表 start 是因為別的重複字元而移動。\n如果有的話，代表是當前最新的重複字元\n綜合以上，就可以得到完整的程式碼了。\n\reasy to understand 解法 \r看到一個比較簡單的解法，有點像是慢慢刪去字串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  def lengthOfLongestSubstring(self, s):\r\u0026#34;\u0026#34;\u0026#34;\r:type s: str\r:rtype: int\r\u0026#34;\u0026#34;\u0026#34;\rstr_list = []\rmax_length = 0\rfor x in s:\rif x in str_list:\rstr_list = str_list[str_list.index(x)+1:]\rstr_list.append(x) max_length = max(max_length, len(str_list))\rreturn max_length\r  這個還蠻好理解的，所以就不說明囉!\n","description":"LeetCode Solving","id":8,"section":"posts","tags":["leetcode","python"],"title":"LeetCode - 3. Longest Substring Without Repeating Characters","uri":"https://stanley98745.github.io/posts/3.longestsubstringwithoutrepeatingcharacters/"},{"content":"題目連結\n\r難度: Easy\n\r題目敘述 Given a non-empty array of integers, every element appears twice except for one. Find that single one.\nNote:\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\nExample 1:\nInput: [2,2,1]\rOutput: 1\r\rExample 2:\nInput: [4,1,2,1,2]\rOutput: 4\r\n解答 1 2 3 4  class Solution:\rdef singleNumber(self, nums: List[int]) -\u0026gt; int:\rreturn 2 * sum(set(nums)) - sum(nums)\r  \r結果 \rRuntime: 84 ms, faster than 83.33% of Python3 online submissions for Single Number.\nMemory Usage: 16.2 MB, less than 6.56% of Python3 online submissions for Single Number.\n\r思路 \r我是用數學的方式來一行解\n題目說每種元素都有兩個，但其中有一種元素只有一個，請找出單獨的元素。\n\n假設nums裡面有 [a, a, b, b, c]\n為了方便理解，我使用有排序的方式，但實際上可能不是按照這樣排序。\n我們把重複的元素去除，加總之後乘以二，得到 2a + 2b + 2c\n而nums的總和為 2a + 2b + c\n相減之後就會得到 single number 了\n\rBitwise解法 XOR 講解 \r恰巧看到一個很有趣的解法，是利用XOR的方式來解決問題。\nXOR在程式中以 「^」來做表示。\n\n首先我們先來看XOR怎麼運作的\n   a b a XOR b     True True False   True False True   False True True   False False False    也就是當a, b都是相同的時候，就會產出False的結果。\n而在二進位中，True就是1，False就是0\n所以也可以變成是\n   a b a XOR b     1 1 0   1 0 1   0 1 1   0 0 0    \n那如果遇到數字又是怎麼運作的呢?\n我們用2, 3來做示範，並將十進位數字轉成二進位\n\r   number 0 0 0     2 0 1 0   3 0 1 1   result 0 0 1    \r所以 2 ^ 3 就會是數字1 (轉換成十進位的結果)\n\n那 2 ^ 2 呢?\n   number 0 0 0     2 0 1 0   2 0 1 0   result 0 0 0    所以 2 ^ 2 就會是數字0 (轉換成十進位的結果)\n而XOR的性質如下\n 交換律： a ^ b = b ^ a 結合律： (a ^ b) ^ c = a ^ (b ^ c) 恆等律： a ^ 0 = a 歸零律： a ^ a = 0  \n那還有一個叫做自反\n 自反： a ^ b ^ b = a  \n所以根據以上性質，我們就可以來使用bitwise 解題\n\n解答 \n1 2 3 4 5 6 7 8  class Solution:\rdef singleNumber(self, nums: List[int]) -\u0026gt; int:\ra = 0\rfor n in nums:\ra ^= n\rreturn\r  \n我們舉 example 2 當例子好了\n\nnums = [4,1,2,1,2]\na = 0\n0 ^ 4 = 4; 把 4 寫入 a\n4 ^ 1 = 5; 把 5 寫入 a\n5 ^ 2 = 7; 把 7 寫入 a\n7 ^ 1 = 6; 把 6 寫入 a\n6 ^ 2 = 4; 把 4 寫入 a\n然後 return a\n\n還是有點怪怪的嗎?\n那我們用數學來跟你講\n0 ^ 4 ^ 1 ^ 2 ^ 1 ^ 2\n= 0 ^ 4 ^ 1 ^ 2 ^ 2 ^ 1\n= 0 ^ 4 ^ 1 ^ 0 ^ 1\n= 0 ^ 4 ^ 1 ^ 1\n= 0 ^ 4 ^ 0\n= 0 ^ 4\n= 4\n以上就是single number的兩種解答囉!\n","description":"LeetCode Solving","id":9,"section":"posts","tags":["leetcode","python"],"title":"LeetCode - 136. Single Number","uri":"https://stanley98745.github.io/posts/136.singlenumber/"},{"content":"題目連結\n\r難度: medium\n\r題目敘述 Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\nFor example, given n = 3, a solution set is:\n[\r\u0026quot;((()))\u0026quot;,\r\u0026quot;(()())\u0026quot;,\r\u0026quot;(())()\u0026quot;,\r\u0026quot;()(())\u0026quot;,\r\u0026quot;()()()\u0026quot;\r]\r\n解答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution:\rdef generateParenthesis(self, n: int) -\u0026gt; List[str]:\rres = []\rdef generator(left, right, curr):\rif left \u0026gt; right:\rreturn\rif not (left\u0026gt;=0 and right\u0026gt;=0):\rreturn\rif left or right:\rgenerator(left-1, right, curr + \u0026#39;(\u0026#39;)\rgenerator(left, right-1, curr + \u0026#39;)\u0026#39;)\relse:\rres.append(curr)\rgenerator(n, n, \u0026#34;\u0026#34;)\rreturn res\r  結果 \rRuntime: 32 ms, faster than 73.15% of Python3 online submissions for Generate Parentheses.\nMemory Usage: 14.2 MB, less than 6.67% of Python3 online submissions for Generate Parentheses.\n\r思路 \r 左括號一定先放，所以數量一定會小於等於右括號。所以我們要排除掉當左括號比較多的情形。  \r1 2  if left \u0026gt; right:\rreturn\r  \r 此外，要確保左與右括號的數量都大於等於零，如果不是，則return。\n因為我們後面會一直傳入 left-1 跟 right-1 的操作。\n有可能會造成數量小於0。\n加入這個判斷式可以確保當傳入的數量小於0，則不要進行任何下一步的操作。\n\n1 2  if not (left\u0026gt;=0 and right\u0026gt;=0):\rreturn\r    \r 在 left 跟 right 都大於0的情況下而我們需要重複呼叫同一個function。\n並且在呼叫之後，讓 left 或是 right 的數量減一，並新增括號。\n若是left跟right都為0，則把字串加入res中。\n\n1 2 3 4 5 6  if left or right:\rgenerator(left-1, right, curr + \u0026#39;(\u0026#39;)\rgenerator(left, right-1, curr + \u0026#39;)\u0026#39;)\relse:\rres.append(curr)\r    \r","description":"LeetCode Solving","id":10,"section":"posts","tags":["leetcode","python"],"title":"LeetCode - 22. Generate Parentheses","uri":"https://stanley98745.github.io/posts/22.generateparentheses/"},{"content":"題目敘述 題目連結\n 難度: Medium\n Given a string, sort it in decreasing order based on the frequency of characters.\nExample 1:\nInput: \u0026quot;tree\u0026quot; Output: \u0026quot;eert\u0026quot; Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore \u0026quot;eetr\u0026quot; is also a valid answer.  Example 2:\nInput: \u0026quot;cccaaa\u0026quot; Output: \u0026quot;cccaaa\u0026quot; Explanation: Both 'c' and 'a' appear three times, so \u0026quot;aaaccc\u0026quot; is also a valid answer. Note that \u0026quot;cacaca\u0026quot; is incorrect, as the same characters must be together.  Example 3:\nInput: \u0026quot;Aabb\u0026quot; Output: \u0026quot;bbAa\u0026quot; Explanation: \u0026quot;bbaA\u0026quot; is also a valid answer, but \u0026quot;Aabb\u0026quot; is incorrect. Note that 'A' and 'a' are treated as two different characters. \n解答 1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: def frequencySort(self, s: str) -\u0026gt; str: from collections import Counter chars = Counter(s) ans = [] for k, v in sorted(chars.items(), key=lambda item: item[1], reverse=True): ans.append(k*v) return \u0026#39;\u0026#39;.join(ans)   結果  Runtime: 32 ms, faster than 94.86% of Python3 online submissions for Sort Characters By Frequency.\nMemory Usage: 15.1 MB, less than 7.14% of Python3 online submissions for Sort Characters By Frequency.\n 思路    第一步是將字元以及出現次數做配對，所以我們可以使用dictionary，讓key為字元，value為次數。\n  呈上，所以我們 import Counter。\n  再來就是比較核心的問題了。\n  個數不同的，越大者往前排。\n  個數相同者，沒關係，怎麼排都對。\n  根據這個想法，所以我們知道了要用value來排序，而且是降冪。\n for k, v in sorted(chars.items(), key=lambda item: item[1], reverse=True):\n稍微講解一下，利用sorted來解決dictionary不能排序問題。\nchars.items() 可以讀出 (key, value) ， items[1] 就是讀出 value。\nreverse = True 即降冪。\n  為了加速，我們把 ans 定為 list，把字元 append 進去之後，最後 return ''.join(ans)。\n如果 ans 用字串來做，也不是不可以，速度會稍微慢一點點而已。\n  \n** 補充小知識 **\n  dict.items() 不能用indexing，也就是 dict.items()[0] 會報錯。\n  lambda 的極簡單用法\n1 2 3  k = lambda x: x * 5 + 1 print(k) print(k(5))    Output:\n\u0026lt;function \u0026lt;lambda\u0026gt; at 0x7f9476deb7b8\u0026gt; 26   ","description":"LeetCode Solving","id":11,"section":"posts","tags":["leetcode","python"],"title":"LeetCode - 451. Sort Characters By Frequency","uri":"https://stanley98745.github.io/posts/451.sortcharactersbyfrequency/"},{"content":"題目敘述 題目連結\n\r難度: Easy\n\rYou are climbing a stair case. It takes n steps to reach to the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\nNote: Given n will be a positive integer.\nExample 1:\nInput: 2\rOutput: 2\rExplanation: There are two ways to climb to the top.\r1. 1 step + 1 step\r2. 2 steps\r\rExample 2:\nInput: 3\rOutput: 3\rExplanation: There are three ways to climb to the top.\r1. 1 step + 1 step + 1 step\r2. 1 step + 2 steps\r3. 2 steps + 1 step\r\n解答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class Solution:\rdef climbStairs(self, n: int) -\u0026gt; int:\rdef quick_combination(m, k):\r# find out C(m, k) value\r count = 1\rif m//2 \u0026lt; k:\rk = m - k\rfor x in range(m, m-k, -1):\rcount *= x\rreturn int(count/factorial(k))\r# b: nums of 2 steps\r ways = 0\rfor b in range(n//2 + 1):\rways += quick_combination(n-b, b)\rreturn ways\r  結果 \rRuntime: 20 ms, faster than 97.36% of Python3 online submissions for Climbing Stairs.\nMemory Usage: 13.8 MB, less than 5.97% of Python3 online submissions for Climbing Stairs.\n\r思路 \r一看到這一題，我心中馬上浮現我在讀高中數學時的題目，7階樓梯每次上一階或兩階，請問有幾種上樓梯的方法?\n我真的超想寫一種，因為我每次上樓梯都兩階兩階爬，哈哈。\n回到正題，這個題目有兩種做法\n  Fibonacci Sequence\n  高中數學的方法\n  第二種就是你列出\n n = 1，爬樓梯組合=?\nn = 2，爬樓梯組合=?\nn = 3，爬樓梯組合=?\nn = 4，爬樓梯組合=?\nn = 5，爬樓梯組合=?\n 那你會發現結果會是呈現出Fibonacci Sequence，那再去推導任意n的情況。\n那今天我們來講第二種\n如何做   先複習這個高中題目怎麼做。\n 假設有七階樓梯，每次只能一階或兩階上樓。\n令一階的次數為 a，兩階的次數為 b\n總階數 = a + 2 * b\n用 b 來列舉可能性\n \r   a b result     7 0 (7 + 0)! / (7! * 0!) = C(7, 0)   5 1 (5 + 1)! / (5! * 1!) = C(6, 1)   3 2 (3 + 2)! / (3! * 2!) = C(5, 2)   1 3 (1 + 3)! / (1! * 3!) = C(4, 3)    \r  可以看到 7, 6, 5, 4 表示目前的上樓梯總數量階數，而 0, 1, 2, 3 表示兩階樓梯的次數。\n那麼你有沒有發現 C(m, n)，每一個的 m + n 都是 7，剛好等於題目的樓梯階數。\n 組合的快速算法。\n  C(m, n) = m! / [(n!) * (m - n)!]\n  C(m, n) = C(m, m - n)\n  舉個例子，假設 C(8, 3) = 8! / (3! * 5!) = (8 * 7 * 6) / (3 * 2 * 1)\n變成分子從8往下數三個數字連乘，而分母為3的階乘。但是按照這樣，C(8, 5) 就會變成\n C(8, 5) = (8 * 7 * 6 * 5 * 4) / (5 * 4 * 3 * 2 * 1)\n 有差嗎?\n有哦! 電腦不會約分\n所以我們將 C(8, 5) 改為 C(8, 3) 就好了，判斷條件為 n 是否大於 m 的一半。\n  加總結果。\n  蠻有趣的一個題目，我看leetcode討論區很多都是用Fibonacci Sequence去解。\n這裡就提供個有趣的做法給大家思考看看囉!\n","description":"LeetCode Solving","id":12,"section":"posts","tags":["leetcode","python"],"title":"LeetCode - 70. Climbing Stairs","uri":"https://stanley98745.github.io/posts/70.climbingstairs/"},{"content":"題目連結\n\r難度: Easy\n\r題目敘述 Given a string containing just the characters \u0026lsquo;(', \u0026lsquo;)', \u0026lsquo;{', \u0026lsquo;}', \u0026lsquo;[\u0026rsquo; and \u0026lsquo;]',\ndetermine if the input string is valid.\nAn input string is valid if:\n Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.  Note that an empty string is also considered valid.\nExample 1:\nInput: \u0026quot;()\u0026quot;\rOutput: true\r\rExample 2:\nInput: \u0026quot;()[]{}\u0026quot;\rOutput: true\r\rExample 3:\nInput: \u0026quot;(]\u0026quot;\rOutput: false\r\rExample 4:\nInput: \u0026quot;([)]\u0026quot;\rOutput: false\r\rExample 5:\nInput: \u0026quot;{[]}\u0026quot;\rOutput: true\r\n解答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution:\rdef isValid(self, s: str) -\u0026gt; bool:\rchars = {\u0026#39;)\u0026#39;: \u0026#39;(\u0026#39;, \u0026#39;]\u0026#39;: \u0026#39;[\u0026#39;, \u0026#39;}\u0026#39;: \u0026#39;{\u0026#39;}\rstack = []\rif len(s) % 2 != 0:\rreturn False\rfor c in s:\rif chars.__contains__(c):\rif not (stack and stack.pop() == chars[c]):\rreturn False\relse:\rstack.append(c)\rif len(stack) == 0:\rreturn True\relse:\rreturn False\r  結果 \rRuntime: 28 ms, faster than 71.18% of Python3 online submissions for Valid Parentheses.\nMemory Usage: 14 MB, less than 5.22% of Python3 online submissions for Valid Parentheses.\n\r思路 \r  括號必然是成雙成對的出現，所以要先排除掉 s 長度不為2的倍數之情況。\n  使用for迴圈去遍歷整個字串 s:\n  遇到左括弧可以直接存在 stack 裡面，但遇到右括弧時要去判斷跟左括弧的配對情況，\n所以此處我們採用dictionary來作括弧的配對，chars = {')': '(', ']': '[', '}': '{'}。\n  若字元是右括弧，則判斷 stack 長度是否為 0 ，如果為 0 代表裡面根本連一個括號都沒有，回傳false。\n  若 stack 長度不為 0 ，則判斷 stack 最後一個元素是不是該右括弧的配對，並且刪除最後一個元素。使用 pop() 來判斷。\n    結束後檢查stack的長度是否為 0 。\n  ","description":"LeetCode Solving","id":13,"section":"posts","tags":["leetcode","python"],"title":"LeetCode - 20. Valid Parentheses","uri":"https://stanley98745.github.io/posts/20.validparentheses/"},{"content":"split() \r用法介紹 \rstr.split(sep=None, maxsplit=-1)\n可以指定分隔符號 sep ，將字串進行分割。\nmaxsplit 用來指定分割的次數。所以總共會得到 maxsplit + 1 個字串。\n sep: 不指定，會用空格來區分。 maxsplit: -1 表示不指定，會將遇到的分隔符號全部分割。 split()只能分割一種分隔符號。\n  範例 \r1 2 3 4  str = \u0026#34;This is a dog, and that is a pig.\u0026#34;\rprint(str.split())\rprint(str.split(\u0026#39;a\u0026#39;, 1)) # separate by \u0026#39;a\u0026#39; at one time\r print(str.split(\u0026#39;z\u0026#39;)) # there is no z char.\r   \n輸出就會變成\n\n1 2 3  [\u0026#39;This\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;dog,\u0026#39;, \u0026#39;and\u0026#39;, \u0026#39;that\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;pig.\u0026#39;] [\u0026#39;This is \u0026#39;, \u0026#39; dog, and that is a pig.\u0026#39;] [\u0026#39;This is a dog, and that is a pig.\u0026#39;]\r  \nre.split() \rre.split() 的好處是可以處理多個分隔符號，並且可以根據正則表示式來作將分隔符號作不同的配對。而在使用之前請先熟悉正則表示式\nRegular Expression Syntax\n用法介紹 \rre.split(pattern, string, maxsplit=0, flags=0)\n pattern: 就是split()中的 sep，可以為單一字符，也可以為正則表示式。 string: 欲分割的字符串。 maxsplit: 分割的最大次數，與split()中不同。  maxsplit \u0026lt; 0: 表示不分割。\nmaxsplit = 0: 全部分割。\nmaxsplit \u0026gt; 0: 分割次數限制。\n  flags: 用來修改pattern表示式的功能。假設今天想要有忽略大小寫的功能，就可以使用flags來修正。 (re.IGNORECASE)。\n  範例 \r1 2 3 4 5 6 7 8 9 10  import re\rstr = \u0026#34;Words, words, words.\u0026#34;\r# \\W equal to \u0026#34;[^A-Za-z0-9_]\u0026#34;\r # + indicates one or more occurrences of the preceding element.\r re.split(r\u0026#39;\\W+\u0026#39;, str) re.split(r\u0026#39;\\W+\u0026#39;, str, 1)\rre.split(\u0026#39;[a-f]+\u0026#39;, \u0026#39;0a3B9\u0026#39;, flags=re.IGNORECASE)\r  \n輸出就會變成\n\n1 2 3  [\u0026#39;Words\u0026#39;, \u0026#39;words\u0026#39;, \u0026#39;words\u0026#39;, \u0026#39;\u0026#39;] [\u0026#39;Words\u0026#39;, \u0026#39;words, words.\u0026#39;]\r[\u0026#39;0\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;9\u0026#39;]\r  其實re.split() 最重要的是在正則表示式，基本上弄懂正則表示式才能夠掌握re.split()。\n文末附上正則表示式的參考資料\n\nRegular_expression wiki\npython - re\n陳鍾誠的網站 - 正則表示式\n","description":"Python skill -- split and re.split","id":14,"section":"posts","tags":["python","string","split","RegExp"],"title":"Python skill -- split and re.split","uri":"https://stanley98745.github.io/posts/split_and_re.split/"},{"content":"前言 上一篇連結在此\n使用Hugo建立網站(MAC) (II)\n本文參考 在github部署hugo靜態網站\n註冊github 首先先到github 註冊帳號。\n你的username就是你未來的github.io前面的名稱。\n如果你的username叫做ccc，那你之後的網址就會叫做\n https://ccc.github.io\n 在github上建立兩個repositories 在github上建立兩個repositories，website-hugo 以及 username.github.io\nwebsite-hugo 這個repository隨便取就好，你要叫blog, new-site, sofarsogood 都可以。\n但是 username.github.io一定要跟自己的帳號一樣。\n像我是stanley98745，建立時就要打上stanley98745.github.io，因為我之前犯蠢，想說可以改別的名字。結果不行!\n 對了別忘記在名稱那邊要打上github.io。\n 建立public資料夾並連結到username.github.io 在blog資料夾底下，我們使用hugo指令來創建public的資料夾。\n(就是一開始hugo new site newsite，你的 newsite 資料夾底下)\n1  hugo   對沒錯，就只有 hugo\n 以下帳號的地方使用username來替代，記得修改成你的帳號哦！\n 1 2 3 4 5 6  cd public git init git remote add origin https://github.com/username/username.github.io.git git add . git commit -m \u0026#34;Initial commit\u0026#34; git push -u origin master   將blog資料夾連結到github上的website-hugo 基本上只有修改成website-hugo，其他都大同小異。\n1 2 3 4 5 6  cd .. git init git remote add origin https://github.com/username/website-hugo.github.io.git git add . git commit -m \u0026#34;Initial commit\u0026#34; git push -u origin master    萬一在 git add . 出現warning，不要怕，別理他。\n 然後等待個幾分鐘，你的 https://username.github.io 就出現囉!\n更新網站 假設你有新的貼文想要上傳，那進到你的 newsite 資料夾底下，在終端機執行以下指令\n1 2 3 4 5  hugo cd public git add . git commit -m \u0026#34;NEW POST\u0026#34; git push origin master   那麼這樣就可以發表新的文章囉!\n使用Hugo建立網站(MAC)的系列文就到這邊啦!\nLinux的架站方式應該跟MAC差不多，所以未來吃飽沒事有機會再使用windows來試試看囉!\n","description":"Hugo建立網站教學","id":15,"section":"posts","tags":["hugo","osx"],"title":"使用Hugo建立網站(MAC) (III)","uri":"https://stanley98745.github.io/posts/hugo_on_mac3/"},{"content":"前言 使用Hugo建立網站(MAC) (I)\n 本篇是介紹zzo這個主題\nzzo hugo theme\nzzo github\n zzo這個主題我其實蠻喜歡的，簡潔明瞭。不但可以放自己的部落格文章、簡報，此外還可以設置集散區域，來秀你的作品集與程式碼。不過我也還在摸索zzo這個主題，包含googleAnalytics，或是他的external libraries。\n那廢話不多說，我們馬上開始。\nConfig ：  注意這邊不是在 theme/zzo 資料夾裡面的 config 資料夾喔!\n 首先我們到config資料夾底下，可以看到 config/_default 資料夾底下有五個檔案，分別是：\n config.toml\nlanguages.toml\nmenus.en.toml\nmenus.ko.toml\nparams.toml\n config.toml 我們擷取部分可能會修改的程式碼\n1 2 3  baseURL = \u0026#34;http://example.org\u0026#34; title = \u0026#34;Hugo Zzo Theme\u0026#34; theme = \u0026#34;zzo\u0026#34;   baseURL：就是你的網址，比如說是https://XXXX.github.io\ntitle：似乎只是描述而已，真正的標籤頁title修改在 languages.toml 中\ntheme：基本上就是zzo\n1 2 3  defaultContentLanguage = \u0026#34;en\u0026#34; defaultContentLanguageInSubdir = true hasCJKLanguage = true   defaultContentLanguage：\n設定default的語言，我這邊是以en為主，不過好像可以改成zh\ndefaultContentLanguageInSubdir：\n讓你的網址後面可以是 網站/en\n像是https://XXXX.github.io/en 可以用來變換不同語言的設定。\nhasCJKLanguage:\nSet “true” for Chinese/Japanese/Korean languages.\n感覺是設定給中日韓語言架站的人使用的。不過我直接用en也可以打中文，所以不清楚差別到底在哪邊。\n1 2 3 4 5 6 7 8 9 10 11  summaryLength = 70 buildFuture = true copyright = \u0026#34;\u0026amp;copy;{year}, All Rights Reserved\u0026#34; timeout = 10000 enableEmoji = true paginate = 13 rssLimit = 100 enableGitInfo = false googleAnalytics = \u0026#34;\u0026#34;   summaryLength:\nThe length of a post description on a list page.\n但是我修改值之後卻發現沒什麼變化，可能還要再試試看。\nbuildFuture:\nif true, we can use future date for talks page\ntalks page是用來放links的列表頁面(video, ppt, \u0026hellip;)，蠻像庫存頁面的樣子。當把這個值改成 false，就可以變成像是先打好文章，然後時間到他就會顯示了。如果是 true，表示可以先看到“未來”的文章。假設你預定明天要發，日期改成明天，那你用localhost來看網站的時候，使用 false 是無法看到的哦。\ncopyright：\n也就是一般網頁最下方會出現的授權標語。\nenableEmoji：\n可以自由決定是否使用表情符號唷！\npaginate：\n決定首頁出現的文章數量。\ngoogleAnalytics:\n這部分還沒測試，但應該是將 UA-XXXX 貼上應該就可以了吧\u0026hellip;？\nlanguages.toml： 1 2 3 4 5 6 7 8 9  [en] title = \u0026#34;Hugo Zzo Theme\u0026#34; languageName = \u0026#34;English\u0026#34; weight = 1 [ko] title = \u0026#34;Hugo Zzo Theme\u0026#34; languageName = \u0026#34;한국어\u0026#34; weight = 2   title：出現在網頁標籤頁之後的標題，並不是在網頁內的標題哦！\n基本上我是將 [ko] 後面的都刪除了。\nmenus.en.toml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  [[main]] identifier = \u0026#34;about\u0026#34; name = \u0026#34;about\u0026#34; url = \u0026#34;about\u0026#34; weight = 1 [[main]] identifier = \u0026#34;archive\u0026#34; name = \u0026#34;archive\u0026#34; url = \u0026#34;archive\u0026#34; weight = 2 [[main]] identifier = \u0026#34;gallery\u0026#34; name = \u0026#34;gallery\u0026#34; url = \u0026#34;gallery\u0026#34; weight = 3 [[main]] parent = \u0026#34;gallery\u0026#34; name = \u0026#34;cartoon\u0026#34; url = \u0026#34;gallery/cartoon\u0026#34; [[main]] parent = \u0026#34;gallery\u0026#34; name = \u0026#34;photo\u0026#34; url = \u0026#34;gallery/photo\u0026#34; [[main]] identifier = \u0026#34;posts\u0026#34; name = \u0026#34;posts\u0026#34; url = \u0026#34;posts\u0026#34; weight = 4 [[main]] identifier = \u0026#34;notes\u0026#34; name = \u0026#34;notes\u0026#34; url = \u0026#34;notes\u0026#34; weight = 5   這個toml代表的是各個頁面的切換\n而目前我只留下 about, archive, posts 而已，並且我修改weight讓他們按照順序。(不過應該是沒有關係啦!)\nidentifier：\n不要修改，是辨識content資料夾底下的東西。\nname：\n可以修改，會顯示在頁面上，比如about可以修改成關於。\nurl：網址顯示的名稱。\nparams.toml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170  logoText = \u0026#34;Zzo\u0026#34; # Logo text that appears in the site navigation bar. logoType = \u0026#34;short\u0026#34; # long, short -\u0026gt; short: squre shape includes logo text, long: rectangle shape not includes logo text logo = true # Logo that appears in the site navigation bar. description = \u0026#34;The Zzo theme for Hugo example site.\u0026#34; # for SEO custom_css = [] # custom_css = [\u0026#34;scss/custom.scss\u0026#34;] and then make file at root/assets/scss/custom.scss custom_js = [] # custom_js = [\u0026#34;js/custom.js\u0026#34;] and then make file at root/assets/js/custom.js useFaviconGenerator = false # https://www.favicon-generator.org/ themeOptions = [\u0026#34;dark\u0026#34;, \u0026#34;light\u0026#34;, \u0026#34;hacker\u0026#34;, \u0026#34;solarized\u0026#34;, \u0026#34;kimbie\u0026#34;] # select options for site color theme notAllowedTypesInHome = [\u0026#34;contact\u0026#34;, \u0026#34;talks\u0026#34;, \u0026#34;about\u0026#34;, \u0026#34;showcase\u0026#34;] # not allowed page types in home page. type can be set in front matter or default to folder name. notAllowedTypesInHomeSidebar = [\u0026#34;about\u0026#34;, \u0026#34;archive\u0026#34;, \u0026#34;showcase\u0026#34;] # not allowed page types in home page sidebar(recent post titles). notAllowedTypesInArchive = [\u0026#34;about\u0026#34;, \u0026#34;talks\u0026#34;, \u0026#34;showcase\u0026#34;] # not allowed page types in archive page # header homeHeaderType = \u0026#34;text\u0026#34; # text, img, slide # navbar enableThemeChange = true # site color theme # body enableBreadcrumb = true # breadcrumb for list, single page enableSearch = true # site search with Fuse enableSearchHighlight = true # when true, search keyword will be highlighted enableGoToTop = true # scroll to top enableWhoami = true # at the end of single page summaryShape = \u0026#34;classic\u0026#34; # card, classic, compact searchResultPosition = \u0026#34;main\u0026#34; # side, main archiveGroupByDate = \u0026#34;2006\u0026#34; # \u0026#34;2006-01\u0026#34;: group by month, \u0026#34;2006\u0026#34;: group by year archivePaginate = 13 # items per page paginateWindow = 1 # setting it to 1 gives 7 buttons, 2 gives 9, etc. If set 1: [1 ... 4 5 6 ... 356] [1 2 3 4 5 ... 356] etc talksPaginate = 8 # items per page talksGroupByDate = \u0026#34;2006\u0026#34; # \u0026#34;2006-01\u0026#34;: group by month, \u0026#34;2006\u0026#34;: group by year # whoami: usage - home page sidebar, single page bottom of post. all values can be empty myname = \u0026#34;zzossig\u0026#34; email = \u0026#34;zzossig@gmail.com\u0026#34; whoami = \u0026#34;Web Developer\u0026#34; bioImageUrl = \u0026#34;\u0026#34; # image url like http//... If not set, we find a avatar image in root/static/images/whoami/avatar.(png|jpg|svg) useGravatar = false # we use this option highest priority location = \u0026#34;Seoul, Korea\u0026#34; organization = \u0026#34;Hugo\u0026#34; link = \u0026#34;https://github.com/zzossig/hugo-theme-zzo\u0026#34; # sidebar enableBio = true # home page sidebar enableSidebar = true # Set to false to create the full width of the content. enableSidebarTags = true # if you want to use tags. enableSidebarSeries = true enableSidebarCategories = true enableHomeSidebarTitles = true enableListSidebarTitles = true enableToc = true # single page table of contents, you can replace this param to toc(toc = true) hideToc = false # Hide or Show toc tocPosition = \u0026#34;inner\u0026#34; # inner, outer enableTocSwitch = true # single page table of contents visibility switch itemsPerCategory = 5 # maximum number of posts shown in the sidebar. sidebarPosition = \u0026#34;right\u0026#34; # bio, profile component layout position # footer showPoweredBy = true # show footer text: Powered by Hugo and Zzo theme showFeedLinks = true # RSS Feed showSocialLinks = true # email, facebook, twitter ... enableLangChange = true # show button at bottom left of footer. # service baiduAnalytics = \u0026#34;\u0026#34; # alternative of google analytics enableBusuanzi = false # if set true, total page view, total unique visitors show up in the footer. busuanziSiteUV = true # unique visitors (total number of visitors) busuanziSitePV = true # site total page view count busuanziPagePV = true # post view count # rss updatePeriod = \u0026#34;\u0026#34; # Possible values: \u0026#39;hourly\u0026#39;, \u0026#39;daily\u0026#39;, \u0026#39;weekly\u0026#39;, \u0026#39;monthly\u0026#39;, or \u0026#39;yearly\u0026#39;. updateFrequency = \u0026#34;\u0026#34; fullContents = false # comment enableComment = true disqus_shortname = \u0026#34;\u0026#34; commento = false [gitment] # Gitment is a comment system based on GitHub issues. see https://github.com/imsun/gitment owner = \u0026#34;\u0026#34; # Your GitHub ID repo = \u0026#34;\u0026#34; # The repo to store comments clientId = \u0026#34;\u0026#34; # Your client ID clientSecret = \u0026#34;\u0026#34; # Your client secret [utterances] # https://utteranc.es/ owner = \u0026#34;\u0026#34; # Your GitHub ID repo = \u0026#34;\u0026#34; # The repo to store comments [gitalk] # Gitalk is a comment system based on GitHub issues. see https://github.com/gitalk/gitalk owner = \u0026#34;\u0026#34; # Your GitHub ID repo = \u0026#34;\u0026#34; # The repo to store comments clientId = \u0026#34;\u0026#34; # Your client ID clientSecret = \u0026#34;\u0026#34; # Your client secret # Valine. # You can get your appid and appkey from https://leancloud.cn # more info please open https://valine.js.org [valine] enable = false appId = \u0026#39;你的appId\u0026#39; appKey = \u0026#39;你的appKey\u0026#39; notify = false # mail notifier , https://github.com/xCss/Valine/wiki verify = false # Verification code avatar = \u0026#39;mm\u0026#39; placeholder = \u0026#39;说点什么吧...\u0026#39; visitor = false [changyan] changyanAppid = \u0026#34;\u0026#34; # Changyan app id # 畅言 changyanAppkey = \u0026#34;\u0026#34; # Changyan app key [livere] livereUID = \u0026#34;\u0026#34; # LiveRe UID # 来必力 # Isso: https://posativ.org/isso/ [isso] enable = false scriptSrc = \u0026#34;\u0026#34; # \u0026#34;https://isso.example.com/js/embed.min.js\u0026#34; dataAttrs = \u0026#34;\u0026#34; # \u0026#34;data-isso=\u0026#39;https://isso.example.com\u0026#39; data-isso-require-author=\u0026#39;true\u0026#39;\u0026#34; [socialOptions] # if set, social icons will show up. email = \u0026#34;mailto:your@email.com\u0026#34; phone = \u0026#34;\u0026#34; facebook = \u0026#34;http://example.org/\u0026#34; twitter = \u0026#34;http://example.org/\u0026#34; github = \u0026#34;https://github.com/zzossig/hugo-theme-zzo\u0026#34; stack-overflow = \u0026#34;\u0026#34; instagram = \u0026#34;\u0026#34; google-plus = \u0026#34;\u0026#34; youtube = \u0026#34;\u0026#34; medium = \u0026#34;\u0026#34; tumblr = \u0026#34;\u0026#34; linkedin = \u0026#34;\u0026#34; pinterest = \u0026#34;\u0026#34; stack-exchange = \u0026#34;\u0026#34; telegram = \u0026#34;\u0026#34; steam = \u0026#34;\u0026#34; weibo = \u0026#34;\u0026#34; douban = \u0026#34;\u0026#34; csdn = \u0026#34;\u0026#34; gitlab = \u0026#34;\u0026#34; mastodon = \u0026#34;\u0026#34; jianshu = \u0026#34;\u0026#34; zhihu = \u0026#34;\u0026#34; signal = \u0026#34;\u0026#34; whatsapp = \u0026#34;\u0026#34; [donationOptions] enable = false # if set, the donation button will show up on the single page. alipay = \u0026#34;\u0026#34; # Alipay QR Code image (example path: images/donation/alipay-qrcode.png) and put your file at root/static/images/donation/ wechat = \u0026#34;\u0026#34; # Wechat pay QR Code image (example path: same as above) paypal = \u0026#34;\u0026#34; # Paypal URL patreon = \u0026#34;\u0026#34; # Patreon URL bitcoin = \u0026#34;\u0026#34; # example path: images/donation/bitcoin-code-image.png [copyrightOptions] enableCopyrightLink = false # if set, you can add copyright link copyrightLink = \u0026#34;\u0026#34; copyrightLinkImage = \u0026#34;\u0026#34; copyrightLinkText = \u0026#34;\u0026#34; # possible share name: [\u0026#34;facebook\u0026#34;,\u0026#34;twitter\u0026#34;, \u0026#34;reddit\u0026#34;, \u0026#34;linkedin\u0026#34;, \u0026#34;tumblr\u0026#34;, \u0026#34;weibo\u0026#34;, \u0026#34;douban\u0026#34;, \u0026#34;line\u0026#34;] [[share]] name = \u0026#34;facebook\u0026#34; [[share]] name = \u0026#34;twitter\u0026#34; username = \u0026#34;\u0026#34;   有一點多，我只講述我修改的部分。\nlogoText：\n如圖，修改的是這個地方的標題。\ndescription：\nSEO的keyword\n接著是修改home page側邊欄的個人資料\n myname = \u0026ldquo;zzossig\u0026rdquo;\nemail = \u0026ldquo;zzossig@gmail.com\u0026rdquo;\nwhoami = \u0026ldquo;Web Developer\u0026rdquo;\nbioImageUrl = \u0026quot;\u0026rdquo;\nuseGravatar = false # we use this option highest priority\nlocation = \u0026ldquo;Seoul, Korea\u0026rdquo;\norganization = \u0026ldquo;Hugo\u0026rdquo;\nlink = \u0026ldquo;https://github.com/zzossig/hugo-theme-zzo\u0026quot;\n 其中要比較注意的是 bioImageUrl ，會讀取 static/images/whoami/avatar.jpg ，要不就是貼圖片網址，要不就是將 avatar.jpg 改成你要的圖片。\nenableLangChange：\n因為我只用一種語言，所以我把這個取消。假設你有韓文跟英文的網頁，就可以用這個來替換，會出現一個按鈕在最下方的左邊。\nenableBusuanzi：\ntotal views與total vistors，會在page最下方顯示。\n[socialOptions]\n總之就是修改你的個人資料，會在側邊欄以及最下方顯示出來，可以放Facebook, Linkedin, Youtube, \u0026hellip;。\nContent 在 content 資料夾底下預設會有 en 以及 ko 兩個資料夾，我自己是把 ko 資料夾刪除了，而 en 資料夾底下只留了 about, archive, posts ，可以根據你自己的需求，來做選擇。不過要提醒，可能要先理解 markdown 的語法，再來進行修改哦。\n除此之外，還有一個檔案叫做 _index.md，主要在修改網頁的主標題、副標題與背景顏色和大小，而我只修改 title 跟 subtitle ，可以看下面的圖來理解。\n基本上大致會修改的地方就是這兩個資料夾了。下一篇我們將介紹如何把網站丟到github上並且發布。\n下一篇連結在此\n使用Hugo建立網站(MAC) (III)\n","description":"Hugo建立網站教學","id":16,"section":"posts","tags":["hugo","osx"],"title":"使用Hugo建立網站(MAC) (II)","uri":"https://stanley98745.github.io/posts/hugo_on_mac2/"},{"content":"OS: Mac OSX\n嘗試使用window10，但不知道為什麼localhost:1313就是不給看。\n一氣之下拿起我的陳年Mac來架站。\nHomebrew \u0026amp; Hugo安裝 ： 若沒有安裝homebrew, 請先安裝homebrew\n升級homebrew，以及安裝git (optional)與hugo\n1 2 3  $ brew update \u0026amp; upgrade $ brew install git $ brew install hugo   建立網站： 首先開啟終端機，並移動到目標路徑，然後利用hugo指令建立出一個叫 blog 的資料夾，你也可以替換你自己想要的名稱。再來部落格主題，我這邊採用zzo的主題。如果你想要別的主題，可以到 hugo themes 搜尋你想要的主題，但由於每個作者習慣不同，所以在後面設定config.toml時會有點不同。\n1 2 3 4 5 6  $ hugo new site blog $ cd blog/themes $ git clone themes website $ git clone https://github.com/zzossig/hugo-theme-zzo.git $ cp -r zzo/exampleSite/** ../ $ cd ..    以上如果你採用的是其他主題，那在 cp 那行，zzo就應該改成你主題的名字。\n 如果你是想要替換主題，就將 git clone 那行改成以下形式。\n1  git submodule add https://github.com/zzossig/hugo-theme-zzo.git   通常在發布網站之前，我們會使用localhost:1313來看自己做的網站有沒有問題。\n1  hugo serve   然後在網頁上面打上 localhost:1313 ，就可以看到你的成品了。\n修改樣板： 一般來說複製 exampleSite 資料夾中的所有檔案到blog資料夾底下就ok了。同時 config.toml 就是我們要修改的對象。但是zzo的主題，config.toml 是放在 config 資料夾底下，所以我們要進去 config/_default 資料夾底下修改 config.toml\n因此我把 zzo theme 的 config.toml 修改放在下一篇，這樣文章內容會比較一致。\n其他主題則需要看一下作者github的 README ，千萬要多小心哦。\n發表文章 在 blog/content 資料夾底下應該可以找到post資料夾，有的還會放在更深的一層，像是zzo的主題就放在 content/en 資料夾底下。如果想要發表文章，只需要\n1  hugo new posts/your-post.md   大致上就是這樣子囉！\n下一篇連結在此\n使用Hugo建立網站(MAC) (II)\n","description":"Hugo建立網站教學","id":17,"section":"posts","tags":["hugo","osx"],"title":"使用Hugo建立網站(MAC) (I)","uri":"https://stanley98745.github.io/posts/hugo_on_mac1/"},{"content":"Stanley, 對科學理論與程式技術有著高度熱忱，喜歡東摸摸西摸摸，人稱雜學大師。目前為接案工作者，使用 python 來撰寫科學計算與相關應用軟體。量子力學、分子動力學、第一原理計算、光學模擬都略懂略懂。目前對於人工智慧相當有興趣，努力自學中，也正準備嘗試某些領域的應用，但會不會變成是自high的情況呢？ 讓我們拭目以待。\n目前想做的事情：  Deep Learning 理論學習與實際應用實作 python 技術整理 學會打網球  服務過的專案有：   科學計算\n\u0026ndash; 分子動力學研究 HfO2 再結晶化條件 (TSMC)\n\u0026ndash; 多尺度模擬開發新型含磷硬化劑 (NAN YA PLASTICS)\n\u0026ndash; 分子動力學研究PVDF參雜石墨烯之相轉變情形 (NTUST)\n\u0026ndash; 矽酸鈉水溶液參雜石墨烯之難溶行為研究 (NTUST)\n  利用python模組開發\n\u0026ndash; 客製化分子模擬模組以研究類鑽石材料之探針摩擦行為 (CCU)\n\u0026ndash; 液晶材料之熱膨脹行為之模擬模組開發案 (NTUT)\n\u0026ndash; 車輛影像測定實際車速之模組開發 (III)\n  其他\n\u0026ndash; NVIDIA DeepStream 以及Jetson Xavier開發之研究 (III)\n  若你有任何問題，請 mail我\n","description":"Stanley introduces himself","id":18,"section":"","tags":null,"title":"About","uri":"https://stanley98745.github.io/about/"}]